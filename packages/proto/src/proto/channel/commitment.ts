// @ts-nocheck
/* eslint-disable */
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: channel/commitment.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../cosmos/base/v1beta1/coin";
import * as pb_1 from "google-protobuf";
export namespace channel.channel {
    export class Commitment extends pb_1.Message {
        #one_of_decls = [];
        constructor(data?: any[] | {
            Index?: string;
            From?: string;
            CoinToCreator?: dependency_1.cosmos.base.v1beta1.Coin;
            ToTimelockAddr?: string;
            ToHashlockAddr?: string;
            CoinToHtlc?: dependency_1.cosmos.base.v1beta1.Coin;
            Timelock?: number;
            Hashcode?: string;
            ChannelID?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Index" in data && data.Index != undefined) {
                    this.Index = data.Index;
                }
                if ("From" in data && data.From != undefined) {
                    this.From = data.From;
                }
                if ("CoinToCreator" in data && data.CoinToCreator != undefined) {
                    this.CoinToCreator = data.CoinToCreator;
                }
                if ("ToTimelockAddr" in data && data.ToTimelockAddr != undefined) {
                    this.ToTimelockAddr = data.ToTimelockAddr;
                }
                if ("ToHashlockAddr" in data && data.ToHashlockAddr != undefined) {
                    this.ToHashlockAddr = data.ToHashlockAddr;
                }
                if ("CoinToHtlc" in data && data.CoinToHtlc != undefined) {
                    this.CoinToHtlc = data.CoinToHtlc;
                }
                if ("Timelock" in data && data.Timelock != undefined) {
                    this.Timelock = data.Timelock;
                }
                if ("Hashcode" in data && data.Hashcode != undefined) {
                    this.Hashcode = data.Hashcode;
                }
                if ("ChannelID" in data && data.ChannelID != undefined) {
                    this.ChannelID = data.ChannelID;
                }
            }
        }
        get Index() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Index(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get From() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set From(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get CoinToCreator() {
            return pb_1.Message.getWrapperField(this, dependency_1.cosmos.base.v1beta1.Coin, 3) as dependency_1.cosmos.base.v1beta1.Coin;
        }
        set CoinToCreator(value: dependency_1.cosmos.base.v1beta1.Coin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get ToTimelockAddr() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set ToTimelockAddr(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get ToHashlockAddr() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set ToHashlockAddr(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get CoinToHtlc() {
            return pb_1.Message.getWrapperField(this, dependency_1.cosmos.base.v1beta1.Coin, 6) as dependency_1.cosmos.base.v1beta1.Coin;
        }
        set CoinToHtlc(value: dependency_1.cosmos.base.v1beta1.Coin) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get Timelock() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set Timelock(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get Hashcode() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set Hashcode(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get ChannelID() {
            return pb_1.Message.getField(this, 9) as string;
        }
        set ChannelID(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            Index?: string;
            From?: string;
            CoinToCreator?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
            ToTimelockAddr?: string;
            ToHashlockAddr?: string;
            CoinToHtlc?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
            Timelock?: number;
            Hashcode?: string;
            ChannelID?: string;
        }) {
            const message = new Commitment({});
            if (data.Index != null) {
                message.Index = data.Index;
            }
            if (data.From != null) {
                message.From = data.From;
            }
            if (data.CoinToCreator != null) {
                message.CoinToCreator = dependency_1.cosmos.base.v1beta1.Coin.fromObject(data.CoinToCreator);
            }
            if (data.ToTimelockAddr != null) {
                message.ToTimelockAddr = data.ToTimelockAddr;
            }
            if (data.ToHashlockAddr != null) {
                message.ToHashlockAddr = data.ToHashlockAddr;
            }
            if (data.CoinToHtlc != null) {
                message.CoinToHtlc = dependency_1.cosmos.base.v1beta1.Coin.fromObject(data.CoinToHtlc);
            }
            if (data.Timelock != null) {
                message.Timelock = data.Timelock;
            }
            if (data.Hashcode != null) {
                message.Hashcode = data.Hashcode;
            }
            if (data.ChannelID != null) {
                message.ChannelID = data.ChannelID;
            }
            return message;
        }
        toObject() {
            const data: {
                Index?: string;
                From?: string;
                CoinToCreator?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
                ToTimelockAddr?: string;
                ToHashlockAddr?: string;
                CoinToHtlc?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
                Timelock?: number;
                Hashcode?: string;
                ChannelID?: string;
            } = {};
            if (this.Index != null) {
                data.Index = this.Index;
            }
            if (this.From != null) {
                data.From = this.From;
            }
            if (this.CoinToCreator != null) {
                data.CoinToCreator = this.CoinToCreator.toObject();
            }
            if (this.ToTimelockAddr != null) {
                data.ToTimelockAddr = this.ToTimelockAddr;
            }
            if (this.ToHashlockAddr != null) {
                data.ToHashlockAddr = this.ToHashlockAddr;
            }
            if (this.CoinToHtlc != null) {
                data.CoinToHtlc = this.CoinToHtlc.toObject();
            }
            if (this.Timelock != null) {
                data.Timelock = this.Timelock;
            }
            if (this.Hashcode != null) {
                data.Hashcode = this.Hashcode;
            }
            if (this.ChannelID != null) {
                data.ChannelID = this.ChannelID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Index === "string" && this.Index.length)
                writer.writeString(1, this.Index);
            if (typeof this.From === "string" && this.From.length)
                writer.writeString(2, this.From);
            if (this.CoinToCreator !== undefined)
                writer.writeMessage(3, this.CoinToCreator, () => this.CoinToCreator.serialize(writer));
            if (typeof this.ToTimelockAddr === "string" && this.ToTimelockAddr.length)
                writer.writeString(4, this.ToTimelockAddr);
            if (typeof this.ToHashlockAddr === "string" && this.ToHashlockAddr.length)
                writer.writeString(5, this.ToHashlockAddr);
            if (this.CoinToHtlc !== undefined)
                writer.writeMessage(6, this.CoinToHtlc, () => this.CoinToHtlc.serialize(writer));
            if (this.Timelock !== undefined)
                writer.writeUint64(7, this.Timelock);
            if (typeof this.Hashcode === "string" && this.Hashcode.length)
                writer.writeString(8, this.Hashcode);
            if (typeof this.ChannelID === "string" && this.ChannelID.length)
                writer.writeString(9, this.ChannelID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Commitment {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Commitment();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Index = reader.readString();
                        break;
                    case 2:
                        message.From = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.CoinToCreator, () => message.CoinToCreator = dependency_1.cosmos.base.v1beta1.Coin.deserialize(reader));
                        break;
                    case 4:
                        message.ToTimelockAddr = reader.readString();
                        break;
                    case 5:
                        message.ToHashlockAddr = reader.readString();
                        break;
                    case 6:
                        reader.readMessage(message.CoinToHtlc, () => message.CoinToHtlc = dependency_1.cosmos.base.v1beta1.Coin.deserialize(reader));
                        break;
                    case 7:
                        message.Timelock = reader.readUint64();
                        break;
                    case 8:
                        message.Hashcode = reader.readString();
                        break;
                    case 9:
                        message.ChannelID = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Commitment {
            return Commitment.deserialize(bytes);
        }
    }
}
